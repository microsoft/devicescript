# DeviceScript Language

DeviceScript generally works just like TypeScript, unless the compiler tells you something is not supported.

## TypeScript subset

DeviceScript is a subset of [TypeScript](https://www.typescriptlang.org).
TypeScript itself follows semantics of ECMAScript also known as JavaScript (JS).
DeviceScript (DS) generally also follows JavaScript semantics, and the DeviceScript compiler
will give you an error if you're using an unsupported feature.

The main difference in semantics between DeviceScript and JavaScript is that DeviceScript programs run in multiple fibers (threads).
In practice, this behaves like JS with `async`/`await` but without an ability to manipulate promises directly
(that is fibers can only interleave at `await` points and at most one fiber runs at any given time).
The compiler enforces usage of `await` where needed.

Please check [semantic differences between DeviceScript and JavaScript](/language/devicescript-vs-javascript) for differences
that the compiler can't warn you about.

Below we list supported and unsupported langauge features.

### Supported language features

-   variable declarations with `let`, `const`
-   functions with lexical scoping and recursion
-   top-level code in the file; hello world really is `console.log("Hello world")`
-   `if ... else if ... else` statements
-   `while` and `do ... while` loops
-   `for(;;)` loops
-   `for ... of` statements (see below about `for ... in`)
-   `break/continue`; also with labeled loops
-   `switch` statement (on numbers, strings, and arbitrary types - the last one isn't very useful)
-   `debugger` statement for breakpoints
-   conditional operator `? :`; lazy boolean operators
-   all arithmetic operators (including bitwise operators)
-   strings (with a few common methods)
-   [string templates](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals) (`` `x is ${x}` ``)
-   arrow functions `() => ...`; passing functions as values
-   classes with inheritance, instance fields, methods and constructors; `new` keyword
-   `public`/`private` annotations on constructor arguments (syntactic sugar to make them into fields); initializers for class fields
-   enumerations (`enum`)
-   generic classes, methods, and functions
-   `typeof` expression
-   binding with arrays or objects: `let [a, b] = ...; let { x, y } = ...`
-   exceptions (`throw`, `try ... catch`, `try ... finally`)
-   `union` or `intersection` types
-   `delete` statement
-   array literals `[1, 2, 3]`
-   object literals `{ foo: 1, bar: "two" }`
-   shorthand properties (`{a, b: 1}` parsed as `{a: a, b: 1}`)
-   computed property names (`{[foo()]: 1, bar: 2}`)
-   spread and rest operators (in certain places)
-   file-based modules (`import * from ...`, `import { foo } from ...` etc)
-   array/object destructuring in parameters and definitions (not in assignments yet)

### Unsupported language features

Things you may miss and we may implement:

-   support of `enums` as run-time arrays
-   static fields and methods in classes
-   method-like properties (get/set accessors)
-   tagged templates `` tag `text ${expression} more text`  `` are limited to special compiler features
    like buffer literals; regular templates are supported
-   assignment operators can't be chained (`x = y = 0`; use `x = 0; y = 0`)

Things that we are not very likely to implement due to the scope of the project
or other constraints (note that if you don't know what a given feature is, you're
unlikely to miss it):

-   `yield` expression and `function*`
-   `with` statement
-   `eval`
-   `for ... in` statements (`for ... of` is supported)
-   JSX (HTML fragments as part of JavaScript)
-   namespaces (we do support ES modules)
-   `arguments` keyword; `.apply` method (modern spread operator is supported)
-   marking properties as non-enumerable etc

## Logging and format strings

The `console.log()` takes zero or more arguments of any type.
Template literals and string concatenation are also supported.
Compiler internally constructs a format string (see below).

```ts
let x = 0
let y = 4
console.log("Hello world")
console.log("X is", x, "and Y is", y)
console.log("X=", x, "Y=", y)
console.log(`X=${x} Y=${y}`)
console.log("X=" + x + " Y=" + y)
```

The compiler is smart about adding spaces (the second and third examples will print `X is 7 and Y is 12`
and `X=7 Y=12` respectively).

Concatenation and template literals can be also used to write registers.

```ts skip
const screen = new ds.CharacterScreen()
let x = 7
screen.message.write("X = " + x)
screen.message.write(`X is ${x}`)
```

You can also use the `ds.format()` function directly, either with `console.log()` or
when setting string registers.
Arguments are `{0}`, `{1}`, ..., `{9}`, `{A}`, `{B}`, ..., `{F}`.
A second digit can be supplied to specify precision (though this doesn't work so well yet):

```ts skip
const screen = new ds.CharacterScreen()
let x = 7,
    y = 12

console.log(ds.format("X is {0} and Y is {1}", x, y))
console.log(ds.format("X = {04}", x))
screen.message.write(ds.format("X is {0}", x))
```
