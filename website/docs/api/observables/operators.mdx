---
title: Operators
---

# Operators

Observable operators apply transformation between observable data stream. They can be combined using the `pipe`
method to create complex data processing pipeline.

Many (most) operators are adapted from [Rxjs](https://rxjs.dev/guide/operators).

```ts
import { Temperature } from "@devicescript/core"
import { threshold, debounceTime } from "@devicescript/observables"

const thermometer = new Temperature()
// create a stream of temperature readings
const temperature = thermometer.temperature.pipe(
    threshold(0.1), // at least 0.1deg change
    debounceTime(10000) // at most one update per 10s
)
await temperature.subscribe(t => console.log(t))
```

## Creation Operators

### from

Converts an array into a sequence of values.

```rx
> from([a,b, c, d])

-a-b-c-d-|-
```

```ts
import { from } from "@devicescript/observables"

// highlight-next-line
const obs = from([0, 1, 2, 3, 4])

await obs.subscribe(v => console.log(v))
```

### interval

Emits a value at a time interval. The value is the number of callbacks.
This observable runs forever.

```rx
> interval(1000)

-0--1--2--3-
```

```ts
import { interval } from "@devicescript/observables"

// highlight-next-line
const obs = interval(1000)

await obs.subscribe(v => console.log(v))
```

### timer

Emits a single value, `0` after a time interval, then completes.

```rx
> timer(1000)

---0-|-
```

```ts
import { timer } from "@devicescript/observables"

// highlight-next-line
const obs = timer(1000)

await obs.subscribe(v => console.log(v))
```

### iif

Checks a boolean at subscription time, and chooses between one of two observable sources.

```ts
import { iif } from "@devicescript/observables"

let connected: boolean
// highlight-next-line
const obs = iif(() => connected, from(["connected"]), from(["not connected"]))

await obs.subscribe(v => console.log(v))
```

## Filter Operators

### filter

Filter items emitted by the source Observable by only emitting those that satisfy a specified predicate.

```rx
-0-1-2-3-1-|-

> filter(v => v > 1)

-----2-3---|-
```

```ts
import { from, filter } from "@devicescript/observables"

const obs = from([0, 1, 2, 3, 1])

await obs
    // highlight-next-line
    .pipe(filter(v => v > 1))
    .subscribe(v => console.log(v))
```

### debounceTime

Emits a notification from the source Observable
only after a particular time span has passed without another source emission.

```rx
-0-1----3----

> debounceTime(2)

-----0----3-
```

The example below debounce a button down event to one every 5 seconds.

```ts
import { Button } from "@devicescript/core"
import { debounceTime } from "@devicescript/observables"

const button = new Button()

await button.down
    // highlight-next-line
    .pipe(debounceTime(5000))
    .subscribe(() => console.log("click"))
```

### throttleTime

Emits a value from the source Observable,
then ignores subsequent source values for duration milliseconds, then repeats this process.

```rx
-0-1-2-3-4-

> throttleTime(2)

-0---2---4-
```

The example below debounce a button down event to one every 5 seconds.

```ts
import { Button } from "@devicescript/core"
import { throttleTime } from "@devicescript/observables"

const button = new Button()

await button.down
    // highlight-next-line
    .pipe(throttleTime(1000))
    .subscribe(() => console.log("click"))
```

### auditTime

Ignores source values for duration milliseconds,
then emits the most recent value from the source Observable, then repeats this process

`auditTime` is similar to `throttleTime`, but emits the last value from the silenced time window, instead of the first value.

```rx
-0-1-2-3-4-

> auditTime(2)

-----2--4-
```

The example below debounce a button down event to one every 5 seconds.

```ts
import { Button } from "@devicescript/core"
import { auditTime } from "@devicescript/observables"

const button = new Button()

await button.down
    // highlight-next-line
    .pipe(auditTime(1000))
    .subscribe(() => console.log("click"))
```

### threshold

Filters numerical data stream within change threshold.

```rx
-0-1-2-1-0-

> threshold(2)

-0---2---0-
```

The example tracks the temperature returned

```ts
import { Temperature } from "@devicescript/core"
import { threshold } from "@devicescript/observables"

const thermometer = new Temperature()

await thermometer.temperature
    // highlight-next-line
    .pipe(threshold(2))
    .subscribe(t => console.log(t))
```

### distinctUntilChanged

Returns a result Observable that emits all values pushed by the source observable
if they are distinct in comparison to the last value the result observable emitted.

This function can be used to create user-friendly transformer. For example, thershold is as follows:

```ts skip
export function threshold<T = number>(
    value: number,
    ...
): OperatorFunction<T, T> {
    return distinctUntilChanged<T, number>(
        (l, r) => Math.abs(l - r) < value,
        keySelector
    )
}
```

## Transform operators

### map

Applies a converter function to converts the observed value into a new value.

```rx
-1--2--3-

> map(x => x * x)

-1--4--9-
```

```ts
import { from, map } from "@devicescript/observables"

const obs = from([1, 2, 3])

await obs
    // highlight-next-line
    .pipe(map(v => v * v))
    .subscribe(v => console.log(v))
```

### scan

Applies an accumulator (or "reducer function") to each value from the source.

```rx
-1---2---3-

> scan((p, c) => p + c, 0)

-1---3---6-
```

```ts
import { from, scan } from "@devicescript/observables"

const obs = from([1, 2, 3])

await obs
    .pipe(
        // highlight-next-line
        scan((p, c) => p + c, 0)
    )
    .subscribe(v => console.log(v))
```

## Signal processing

### ewma

Exponentially weighted moving average is a simple PIR filter
with a gain parameter.
The closer gain to 1 and the more closely the EWMA tracks the original time series.

```ts
import { Temperature } from "@devicescript/core"
import { ewma } from "@devicescript/observables"

const thermometer = new Temperature()

await thermometer.temperature
    // highlight-next-line
    .pipe(ewma(0.5))
    .subscribe(t => console.log(t))
```

### rollingAverage

A windowed rolling average filter.

```ts
import { Temperature } from "@devicescript/core"
import { rollingAverage } from "@devicescript/observables"

const thermometer = new Temperature()

await thermometer.temperature
    // highlight-next-line
    .pipe(rollingAverage(10))
    .subscribe(t => console.log(t))
```

### fir

A general purpose Finite Response Filter filter. Coefficients are typically computed in a seperate process.

```ts
import { Temperature } from "@devicescript/core"
import { fir } from "@devicescript/observables"

const thermometer = new Temperature()

await thermometer.temperature
    // highlight-next-line
    .pipe(fir([0.1, 0.2, 1]))
    .subscribe(t => console.log(t))
```

### levelDetector

Measures and thresholds data into low/mid/high levels.

```ts
import { Temperature } from "@devicescript/core"
import { levelDetector } from "@devicescript/observables"

const thermometer = new Temperature()

await thermometer.temperature
    // highlight-next-line
    .pipe(levelDetector(20 /* low threshold */, 30 /*high threshold */))
    .subscribe(level =>
        console.log(level < 0 ? "cold" : level > 0 ? "hot" : "mild")
    )
```

## Error Handling

### throwError

Just errors and does nothing else.

```rx
> throw

-#--------------
```

```ts
import { from, map, throwError } from "@devicescript/observables"

const obs = from([1, 2, 3])

await obs
    .pipe(
        // highlight-next-line
        throwError(() => new Error("no!"))
    )
    .subscribe(v => console.log(v))
```

### catchError

It only listens to the error channel and ignores notifications.
Handles errors from the source observable, and maps them to a new observable.
The error may also be rethrown, or a new error can be thrown to emit an error from the result.

```rx
-a-b--#-------|-

       -1-2-3-|-

> catch

-a-b----1-2-3-|-
```

```ts
import { from, map, throwError, catchError } from "@devicescript/observables"

const obs = from([1, 2, 3])

await obs
    .pipe(
        throwError(() => new Error("no!")),
        // highlight-next-line
        catchError(e => from([4]))
    )
    .subscribe(v => console.log(v))
```

## Utilities

### tap

Allows to attach a side-effect function to a pipeline, tap passes the stream through. Typically used to add logging.

```ts
import { from, map, tap } from "@devicescript/observables"

const obs = from([1, 2, 3])

await obs
    .pipe(
        // highlight-next-line
        tap(v => console.log(v)),
        map(v => v * v)
    )
    .subscribe(v => console.log(v))
```
